#!/usr/bin/env python3
"""
NOTE: The characters after this line may have been generated by a language modeling algorithm.
Visualize SMPL-X time series data extracted from video.
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import argparse


def load_smplx_data(npz_path):
    """Load SMPL-X time series from NPZ file."""
    data = np.load(npz_path, allow_pickle=True)
    return {
        'joint_rotations': data['joint_rotations'],
        'detected': data['detected'],
        'confidences': data['confidences'],
        'global_orientation': data['global_orientation'],
        'fps': float(data['fps']),
        'joint_names': data['joint_names'].tolist() if 'joint_names' in data else None,
    }


def plot_detection_timeline(data, output_path=None):
    """Plot detection status over time."""
    detected = data['detected']
    confidences = data['confidences']
    fps = data['fps']
    
    n_frames = len(detected)
    time = np.arange(n_frames) / fps
    
    fig, axes = plt.subplots(3, 1, figsize=(14, 8))
    
    # Detection status
    axes[0].fill_between(time, 0, detected.astype(int), alpha=0.3, color='green')
    axes[0].set_ylabel('Detected')
    axes[0].set_title('Person Detection Over Time')
    axes[0].set_ylim(-0.1, 1.1)
    axes[0].grid(True, alpha=0.3)
    
    # Detection confidence
    axes[1].plot(time, confidences, linewidth=0.5, alpha=0.7)
    axes[1].fill_between(time, 0, confidences, alpha=0.2)
    axes[1].set_ylabel('Confidence')
    axes[1].set_title('Detection Confidence Score')
    axes[1].set_ylim(0, 1)
    axes[1].grid(True, alpha=0.3)
    
    # Detection statistics (rolling window)
    window = int(fps * 2)  # 2-second window
    if window < len(detected):
        rolling_detection = np.convolve(detected.astype(float), 
                                       np.ones(window)/window, mode='valid')
        rolling_time = time[:len(rolling_detection)]
        axes[2].plot(rolling_time, rolling_detection * 100)
        axes[2].set_ylabel('Detection Rate (%)')
        axes[2].set_title(f'Detection Rate (2-second rolling window)')
        axes[2].set_ylim(0, 100)
        axes[2].grid(True, alpha=0.3)
    
    axes[2].set_xlabel('Time (seconds)')
    
    plt.tight_layout()
    
    if output_path:
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        print(f"Saved detection timeline to: {output_path}")
    else:
        plt.show()


def plot_joint_trajectories(data, joint_indices=None, output_path=None):
    """Plot rotation trajectories for selected joints."""
    joint_rotations = data['joint_rotations']
    detected = data['detected']
    fps = data['fps']
    joint_names = data.get('joint_names', [f"Joint_{i}" for i in range(55)])
    
    if joint_indices is None:
        # Default: plot interesting joints
        joint_indices = [0, 16, 17, 20, 21]  # pelvis, shoulders, wrists
    
    n_frames = len(joint_rotations)
    time = np.arange(n_frames) / fps
    
    fig, axes = plt.subplots(len(joint_indices), 3, figsize=(15, 3*len(joint_indices)))
    if len(joint_indices) == 1:
        axes = axes.reshape(1, -1)
    
    dims = ['X', 'Y', 'Z']
    
    for idx, joint_idx in enumerate(joint_indices):
        joint_name = joint_names[joint_idx] if joint_idx < len(joint_names) else f"Joint_{joint_idx}"
        
        for dim in range(3):
            ax = axes[idx, dim]
            
            # Get rotation data for this joint and dimension
            rotations = joint_rotations[:, joint_idx, dim]
            
            # Plot only detected frames
            valid_mask = detected & ~np.isnan(rotations)
            
            if valid_mask.sum() > 0:
                ax.plot(time[valid_mask], rotations[valid_mask], 
                       linewidth=1, marker='.', markersize=2)
                
                # Highlight gaps (not detected)
                gap_mask = ~valid_mask
                if gap_mask.sum() > 0:
                    ax.scatter(time[gap_mask], 
                             np.zeros(gap_mask.sum()), 
                             c='red', marker='x', s=20, alpha=0.5,
                             label='Not detected')
            
            ax.set_ylabel(f'{dims[dim]} rotation (rad)')
            ax.grid(True, alpha=0.3)
            
            if idx == 0:
                ax.set_title(f'{joint_name} - {dims[dim]} axis')
            else:
                ax.set_title(f'{dims[dim]} axis')
            
            if idx == len(joint_indices) - 1:
                ax.set_xlabel('Time (seconds)')
    
    plt.tight_layout()
    
    if output_path:
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        print(f"Saved joint trajectories to: {output_path}")
    else:
        plt.show()


def plot_joint_heatmap(data, output_path=None):
    """Plot heatmap of joint rotation magnitudes over time."""
    joint_rotations = data['joint_rotations']
    detected = data['detected']
    fps = data['fps']
    joint_names = data.get('joint_names', [f"J{i}" for i in range(55)])
    
    # Calculate rotation magnitude for each joint
    rotation_magnitudes = np.linalg.norm(joint_rotations, axis=2)  # (n_frames, 55)
    
    # Mask undetected frames
    rotation_magnitudes[~detected, :] = np.nan
    
    fig, ax = plt.subplots(figsize=(14, 8))
    
    # Downsample for visualization if too many frames
    n_frames = len(rotation_magnitudes)
    if n_frames > 500:
        step = n_frames // 500
        rotation_magnitudes = rotation_magnitudes[::step]
        time_labels = np.arange(0, n_frames, step) / fps
    else:
        time_labels = np.arange(n_frames) / fps
    
    im = ax.imshow(rotation_magnitudes.T, aspect='auto', cmap='viridis', 
                   interpolation='nearest', origin='lower')
    
    ax.set_xlabel('Time (seconds)')
    ax.set_ylabel('Joint Index')
    ax.set_title('Joint Rotation Magnitudes Over Time')
    
    # Set time axis labels
    n_ticks = min(10, len(time_labels))
    tick_indices = np.linspace(0, len(time_labels)-1, n_ticks, dtype=int)
    ax.set_xticks(tick_indices)
    ax.set_xticklabels([f'{time_labels[i]:.1f}' for i in tick_indices])
    
    # Set joint names on y-axis (sample some)
    n_joint_ticks = min(15, len(joint_names))
    joint_tick_indices = np.linspace(0, len(joint_names)-1, n_joint_ticks, dtype=int)
    ax.set_yticks(joint_tick_indices)
    ax.set_yticklabels([joint_names[i] for i in joint_tick_indices], fontsize=8)
    
    plt.colorbar(im, ax=ax, label='Rotation magnitude (rad)')
    plt.tight_layout()
    
    if output_path:
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        print(f"Saved joint heatmap to: {output_path}")
    else:
        plt.show()


def plot_statistics(data, output_path=None):
    """Plot summary statistics."""
    joint_rotations = data['joint_rotations']
    detected = data['detected']
    confidences = data['confidences']
    
    fig, axes = plt.subplots(2, 2, figsize=(12, 10))
    
    # 1. Detection rate
    ax = axes[0, 0]
    detection_rate = detected.mean() * 100
    ax.bar(['Detected', 'Not Detected'], 
           [detection_rate, 100-detection_rate],
           color=['green', 'red'], alpha=0.6)
    ax.set_ylabel('Percentage of Frames')
    ax.set_title(f'Overall Detection Rate: {detection_rate:.1f}%')
    ax.set_ylim(0, 100)
    for i, (label, val) in enumerate([('Detected', detection_rate), 
                                      ('Not Detected', 100-detection_rate)]):
        ax.text(i, val + 2, f'{val:.1f}%', ha='center', fontsize=12, fontweight='bold')
    
    # 2. Confidence distribution
    ax = axes[0, 1]
    valid_confidences = confidences[detected]
    if len(valid_confidences) > 0:
        ax.hist(valid_confidences, bins=30, alpha=0.7, edgecolor='black')
        ax.axvline(valid_confidences.mean(), color='red', linestyle='--', 
                  linewidth=2, label=f'Mean: {valid_confidences.mean():.3f}')
        ax.set_xlabel('Confidence Score')
        ax.set_ylabel('Number of Frames')
        ax.set_title('Detection Confidence Distribution')
        ax.legend()
    
    # 3. Joint rotation magnitudes
    ax = axes[1, 0]
    rotation_mags = np.linalg.norm(joint_rotations[detected], axis=2)  # (n_detected, 55)
    if len(rotation_mags) > 0:
        mean_rotations = np.nanmean(rotation_mags, axis=0)
        joint_indices = np.arange(len(mean_rotations))
        ax.bar(joint_indices, mean_rotations, alpha=0.6)
        ax.set_xlabel('Joint Index')
        ax.set_ylabel('Mean Rotation Magnitude (rad)')
        ax.set_title('Average Rotation per Joint')
        ax.set_xlim(-1, 55)
        
        # Highlight hand joints
        ax.axvspan(27, 41, alpha=0.2, color='blue', label='Left hand')
        ax.axvspan(42, 54, alpha=0.2, color='green', label='Right hand')
        ax.legend()
    
    # 4. Temporal motion
    ax = axes[1, 1]
    if detected.sum() > 1:
        # Calculate frame-to-frame motion
        detected_frames = joint_rotations[detected]
        frame_motion = np.linalg.norm(
            np.diff(detected_frames, axis=0),
            axis=(1, 2)  # Norm over joints and dimensions
        )
        
        ax.plot(frame_motion, linewidth=1, alpha=0.7)
        ax.axhline(frame_motion.mean(), color='red', linestyle='--',
                  label=f'Mean: {frame_motion.mean():.3f}')
        ax.set_xlabel('Frame (detected frames only)')
        ax.set_ylabel('Total Motion Magnitude')
        ax.set_title('Frame-to-Frame Motion')
        ax.legend()
        ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    if output_path:
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        print(f"Saved statistics to: {output_path}")
    else:
        plt.show()


def main():
    parser = argparse.ArgumentParser(
        description='Visualize SMPL-X time series data'
    )
    parser.add_argument('npz_file', type=str, help='Path to .npz file')
    parser.add_argument('--timeline', action='store_true', 
                       help='Plot detection timeline')
    parser.add_argument('--trajectories', action='store_true',
                       help='Plot joint trajectories')
    parser.add_argument('--heatmap', action='store_true',
                       help='Plot joint rotation heatmap')
    parser.add_argument('--stats', action='store_true',
                       help='Plot summary statistics')
    parser.add_argument('--all', action='store_true',
                       help='Generate all visualizations')
    parser.add_argument('--joints', type=int, nargs='+',
                       help='Joint indices to plot (for trajectories)')
    parser.add_argument('-o', '--output-dir', type=str,
                       help='Directory to save plots (default: show plots)')
    
    args = parser.parse_args()
    
    # Load data
    print(f"Loading data from {args.npz_file}...")
    data = load_smplx_data(args.npz_file)
    
    print(f"Loaded {len(data['detected'])} frames")
    print(f"Detection rate: {data['detected'].mean()*100:.1f}%")
    
    # Determine output paths
    if args.output_dir:
        from pathlib import Path
        output_dir = Path(args.output_dir)
        output_dir.mkdir(exist_ok=True)
        timeline_path = output_dir / 'detection_timeline.png'
        traj_path = output_dir / 'joint_trajectories.png'
        heatmap_path = output_dir / 'joint_heatmap.png'
        stats_path = output_dir / 'statistics.png'
    else:
        timeline_path = traj_path = heatmap_path = stats_path = None
    
    # Generate requested visualizations
    if args.all or args.timeline:
        print("\nGenerating detection timeline...")
        plot_detection_timeline(data, timeline_path)
    
    if args.all or args.trajectories:
        print("\nGenerating joint trajectories...")
        plot_joint_trajectories(data, args.joints, traj_path)
    
    if args.all or args.heatmap:
        print("\nGenerating joint heatmap...")
        plot_joint_heatmap(data, heatmap_path)
    
    if args.all or args.stats:
        print("\nGenerating statistics...")
        plot_statistics(data, stats_path)
    
    if not (args.timeline or args.trajectories or args.heatmap or args.stats or args.all):
        print("\nNo visualization specified. Use --all or specific options.")
        print("Run with --help for more information.")
        
        # Show basic info instead
        print("\n=== Data Summary ===")
        print(f"Total frames: {len(data['detected'])}")
        print(f"Detected frames: {data['detected'].sum()}")
        print(f"Detection rate: {data['detected'].mean()*100:.1f}%")
        print(f"FPS: {data['fps']}")
        print(f"Duration: {len(data['detected'])/data['fps']:.2f} seconds")


if __name__ == '__main__':
    main()
